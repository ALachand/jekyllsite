---
layout: page
title: Mif02 - TP R&eacute;ing&eacute;nierie et design patterns en JAVA
permalink: /cours/2016/mif02/tp-pattern.html
---

<h2>Objectif</h2>
<p>Il vous est demand&eacute; d'effectuer une r&eacute;-ing&eacute;nierie d'un code existant en mettant en oeuvre les patrons de conception vus en cours. Vous allez &eacute;galement concevoir une nouvelle application en utilisant le formalisme UML et en exploitant au maximum les proc&eacute;dures de g&eacute;n&eacute;ration de code et de r&eacute;tro-conception.</p>

<p><strong>Votre travail devra &ecirc;tre rendu sous forme d'un projet déposé sur la Forge Lyon 1, au plus tard le dimanche 2 octobre &agrave; 23h59.
</strong>
</p>


<h2>D&eacute;roulement</h2>

<p>Le travail peut &ecirc;tre organis&eacute;e en deux &eacute;tapes : </p>
<ul>
  <li>la premi&egrave;re sera une &eacute;tape de r&eacute;-ing&eacute;nierie (refactoring) du code des Tortues utilis&eacute; au TP1,
  afin de rendre les packages plus modulaires. </li>
  <li>la seconde sera d&eacute;di&eacute;e &agrave; la conception d'une application permettant &agrave; deux &eacute;quipes de Tortues de jouer au ballon. </li>
</ul>

<h3>Partie 1 : R&eacute;-ing&eacute;nierie du code </h3>

<p>Le code qui est fourni lors de la première séance est un package relativement fouillis. Toutes les classes sont d&eacute;pendantes
les unes des autres, les couches graphique et m&eacute;tier ne sont pas s&eacute;par&eacute;es. </p>
<p>Il va vous falloir reconcevoir le code (et le mod&egrave;le) en appliquant les patrons de conception ad&eacute;quats. Pour cela, vous devez r&eacute;organiser les &eacute;l&eacute;ments de
l'application logo. Entre autres, l'affichage des tortues doit &ecirc;tre s&eacute;par&eacute; de la gestion des tortue, de leurs d&eacute;placements, <i>etc</i>.
Les changements dans le mod&egrave;le m&eacute;tier (d&eacute;placements de la tortue) devront &ecirc;tre r&eacute;percut&eacute;s dans l'affichage.
L'utilisation de l'IHM (boutons) entra&icirc;nera des changements dans le mod&egrave;le m&eacute;tier en passant par un contr&ocirc;leur.
On consid&eacute;rera dans cette partie une IHM simplifi&eacute;e, qui permet juste de commander une Tortue dans ses d&eacute;placements
(avant, arri&egrave;re, droite, gauche). </p>
<!--
<p>Quelques pages li&eacute;es &agrave; MVC pouvant &ecirc;tre utiles : <a href="http://www.java2s.com/Code/Java/Design-Pattern/MVC-Pattern.htm">ici</a>, <a href="http://www.oracle.com/technetwork/articles/javase/mvc-136693.html">ici</a> et <a href="http://www.austintek.com/mvc/">l&agrave;</a>.</p> -->

<h3>Partie 2 : Conception et d&eacute;veloppement d'une nouvelle application</h3>
<p>On reprend la th&eacute;matique g&eacute;n&eacute;rale des tortues qui jouent au ballon, pour concevoir une nouvelle application. L'objectif de l'application est de permettre &agrave; un utilisateur de faire jouer au ballon l'une contre l'autre deux &eacute;quipes de joueurs. Le jeu se passera sur un terrain muni de deux enbuts, l'arriv&eacute;e du ballon dans l'enbut de l'adversaire permettra &agrave; une &eacute;quipe de marquer un point. Un match s'interrompra au bout d'un certain temps.</p>

<p>Chaque &eacute;quipe aura une tactique de jeu, qu'elle pourra changer en cours de partie (action utilisateur). Une tactique concerne la mani&egrave;re de faire r&eacute;agir une &eacute;quipe de fa&ccedil;on <span style="font-style: italic;">globale</span> : mouvements, passes, <span style="font-style: italic;">etc</span>. Une tactique peut d&eacute;pendre de la position des joueurs sur le terrain, de leurs caract&eacute;ristiques individuelles, de leurs positions respectives, de l'&eacute;quipe adverse, <i>etc</i>. On d&eacute;finira au moins trois tactiques diff&eacute;rentes. </p>

<p>Chaque joueur aura des caract&eacute;ristiques individuelles. Les caract&eacute;ristique d&eacute;finissent sa mani&egrave;re de r&eacute;agir quand il a ou n'a pas la balle, en fonction de son placement sur le terrain, de la proximit&eacute; des adversaires, <i>etc</i>. Les caract&eacute;tistiques du joueur d&eacute;terminent la r&eacute;action <span style="font-style: italic;">locale</span> du joueur. On pourra par exemple avoir des d&eacute;fenseurs et des attaquants, des rapides et des lents, etc.</p>

<p>L'action d'un joueur sera donc d&eacute;termin&eacute;e d'une part par la tactique employ&eacute;e dans son &eacute;quipe, d'autre part par ses caract&eacute;ristiques individuelles. A vous d'imaginer comment vous g&eacute;rez ces deux informations. L'utilisateur devra au minimum pouvoir lancer un match entre deux &eacute;quipes, l'interrompre, changer la tactique d'une &eacute;quipe en cours de jeu. On disposera pour suivre le jeu de trois fen&ecirc;tres graphiques au minimum</p>
<ul>
  <li>une pr&eacute;sentant le terrain, les joueurs, la balle, etc., </li>
  <li>une autre pr&eacute;sentant le score et les contr&ocirc;les du jeu</li>
  <li>une troisi&egrave;me pr&eacute;sentant en permanence la couleur de l'&eacute;quipe qui a la balle.</li>
</ul>

<p> <b> Conseils pour la r&eacute;alisation </b> </p>
<p>Faites un mod&egrave;le du domaine du jeu de ballon que vous voulez mettre en place : joueurs, caract&eacute;ristiques joueurs, ballon, tactique, <i>etc</i> en r&eacute;utilisant au maximum le mod&egrave;le correspondant au code mis en place dans la partie 1. Organisez vos classes en packages pertinents. Construisez ensuite le diagramme des classes d'impl&eacute;mentation &agrave; partir du mod&egrave;le du domaine.</p>

<p>Compl&eacute;tez votre conception pour r&eacute;aliser des sc&eacute;narios correspondant &agrave; des interactions diff&eacute;rentes au cours du jeu
(cr&eacute;ation du jeu, phase o&ugrave; une &eacute;quipe &agrave; la balle, passe d'une balle, etc.), notamment avec des diagrammes de s&eacute;quence.
Faites &eacute;voluer les classes avec les besoins identifi&eacute;s, en compl&eacute;tant petit &agrave; petit attributs et m&eacute;thodes (jusqu'&agrave;
ce que vous pensiez que vous pouvez passer au codage). Utilisez diagrammes d'activit&eacute;s et d'&eacute;tats-transitions pour illustrer les diff&eacute;rents
fonctionnements : syst&egrave;me, &eacute;quipe, joueurs, etc.</p>
<p>Une fois vos classes de conception &agrave; peu pr&egrave;s
stabilis&eacute;es, g&eacute;n&eacute;rez le code correspondant
&agrave; votre projet, et utilisez &eacute;ventuellement la proc&eacute;dure de
<i>round trip engineering</i> pour synchroniser en permanence code et mod&egrave;le. Parmi les applications de mod&eacute;lisation UML, vous pouvez utiliser
<a href="http://argouml.tigris.org/">ArgoUML</a>, <a href="http://www.bouml.fr/">BoUML</a>, <a href="http://www.altova.com/umodel.html">UModel</a>... Vous pouvez &eacute;galement utiliser des plugins UML pour <a href="http://plugins.netbeans.org/PluginPortal/">Netbeans</a> ou <a href="http://www.eclipse.org/modeling/mdt/?project=uml2">Eclipse</a>.
</p>



<!--
<h3>Introduction : outils UML</h3>
<p>UModel est  un des outils disponibles &agrave; l'UFR informatique pour la mod&eacute;lisation et le roundtrip engineering.
Mettez rapidement en place un cycle de roundtrip engineering, par exemple sur les Tortues du package <a href="doc/MIF17/logo.tar.gz">logo</a> de base. </p>
<p>Remarque : Netbeans 2.9 n'a plus de composant UML, Netbeans 2.7 en a toujours un qui fonctionne bien.  Si vous &ecirc;tes sur votre machine personnelle,
vous  pouvez utiliser n'importe quel outil UML pour tester les fonctionnalit&eacute;s de roundtrip engineering.<br>
</p>
<p>Au cours du projet, en phase codage, vous pourrez utiliser l'outil UML de votre choix en mettant en place un cycle de roundtrip engineering.</p>
-->



<h2>Rendu du TP</h2>

<h3>Projet Forge et questionnaire</h3>

<p>Votre d&eacute;p&ocirc;t sur la Forge devra contenir :&nbsp;</p>

<ul>
  <li>un fichier README.txt à la racine du projet</li>
  <li>un fichier maven pour le build du projet</li>
  <li>les sources (fichiers Java)&nbsp;</li>
  <li>la documentation javadoc de vos classes&nbsp;</li>
  <li>le rapport en PDF. Il doit comprendre une pr&eacute;sentation globale du projet, une motivation des choix d'architecture (et des patterns choisis), et leur explication en s'aidant de diagrammes appropri&eacute;s et adapt&eacute;s au degr&eacute; de pr&eacute;cision et au type d'explication. Donc diagramme de classe, mais pas que cela et pas de plat de spaghetti illisible repr&eacute;sentant tout le code et g&eacute;n&eacute;r&eacute; automatiquement</li>
  <li>les fichiers natifs de votre modélisation UML (indiquez quel outil a &eacute;t&eacute; utilis&eacute;)</li>
</ul>


<p>Barême indicatif :</p>
<ul>
  <li> R&eacute;alisation : 7 points
    <ul>
      <li> Respect des consignes </li>
      <li> Application des patterns </li>
      <li> Fonctionnement </li>
    </ul></li>
  <li>Rapport : 5 points
    <ul>
      <li> Contenu et forme (voir ci-dessus) </li>
      <li> Orthographe </li>
      <li> Explication des patterns (liens diagrammes - explications) </li>
    </ul></li>
  <li>Mod&eacute;lisation : 5 points
    <ul>
      <li> Patrons utilis&eacute;s </li>
      <li> Diagrammes fournis </li>
    </ul></li>
</ul>
<p><strong>Dans la configuration de votre projet, ajoutez Lionel MEDINI et Aur&eacute;lien TABARD en tant que "reporters". Remplissez &eacute;galement le questionnaire Spiral, ce qui permettra aux intervenants de récupérer automatiquement les projets :</strong>
	  <a href="">Questionnaire Spiral</a>
</p>
